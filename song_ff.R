######## Fundamental frequency ########
calc_ff = function(wav, peaks) {
  
  psd = apply(peaks, 1, function(x) spec(wav, wl = 512, PSD=T, from=x[1], to=x[2], plot=F))
  psd_peaks = lapply(psd, function(data) {
    total_power = sum(data[,2])
    d = findpeaks_freq(data, min_size=0)
    d %>% rowwise() %>% summarize(ins=ins, 
                                  outs=outs, 
                                  prop=sum(data[data[,1]>ins & data[,1]<outs,2])/total_power)
  })
  return(psd_peaks)
}



calc_ff = function(wav, mat) {
  #psd = apply(mat, 1, function(x) spec(wav, PSD=T, from=as.numeric(x["onsets"]), to=as.numeric(x["offsets"]), plot=F))
  #if (class(psd) == "matrix") psd = list(cbind(1:nrow(psd), psd))
  freqs = unlist(lapply(psd, function(data) {
    d = findpeaks_freq(data, min_value=2, max_gap=1000, min_size=0, thresh=.1)
    maxes = apply(d, 1, function(x) max(psd[x[1]:x[2]]))
    d = d[which.max(maxes),]
    #d_mean = apply(d, 1, mean)
    #d_mean = data.frame(ind=1:length(d_mean), d_mean=d_mean)
    #d_freq = apply(d_mean, 1, function(x) x[2]/x[1])
    #mean(d_freq)
  }))
  
  #if (nrow(mat) == 1) {
  #  return(c(mat, freqs))
  #} else {
  return(cbind(mat, freqs))
  #}
}

#' Calculate fundamental frequency by averaging harmonics
#' @param wav, input Wave file
#' @param mat, data.frame containing onsets, offsets, and label as generated by load_mat
#' @param buffer, number of seconds to contract segmented syllable. applied to both onset and offset
#' @param min_freq, parameter supplied to findpeaks_freq, peaks below this value are removed
#' @param error, cv of inferred FF must be below this value
#' @return mat file supplemented with calculated fundamental frequency
calc_ff2 = function(wav, mat, lbuffer=0, rbuffer=0, min_freq=1, error = .01, thresh=.1, wl=1024) {
  fs = wav@samp.rate
  window = wl / fs
  psd = NULL
  #psd = apply(mat, 1, function(x) spec(wav, PSD=T, from=as.numeric(x[1])+buffer, to=as.numeric(x[2])-buffer, plot=F))
  if (nrow(mat)==1) {
    from = as.numeric(mat[1,1])+lbuffer
    to = as.numeric(mat[1,2])+rbuffer
    if ((to-from)<window) {
      psd = NA
    } else {
      psd = spec(wav, wl=wl, PSD=T, from=from, to=to, plot=F)
    }
  } else {
    psd = apply(mat, 1, function(x) {
      from = as.numeric(x[1])+lbuffer
      to = as.numeric(x[2])+rbuffer
      if ((to-from)<window) {
        return(NA)
      } else {
        spec(wav, wl=wl, PSD=T, from=from, to=to, plot=F)
      }
    })
  }
    
  if (is.na(psd))
    return(cbind(mat, ff=NA))
  
  
  if (class(psd) == "matrix") psd = list(psd)
  freqs = unlist(lapply(psd, function(data) {
    if(is.na(data))
      return(NA)
    d = findpeaks_freq(data, min_value=min_freq, max_gap=.4, min_size=0, thresh=thresh)
    if (nrow(d)==1)
      return(mean(d[1,]))
    d_mean = apply(d, 1, mean)
    test_steps = seq(1:nrow(d))
    test_steps1 = lapply(0:3, function(i) test_steps + i)
    
    d_freq = NA
    for (i in 1:length(test_steps1)) {
      d_f = d_mean / test_steps1[[i]]
      cv = sd(d_f)/mean(d_f)
      #if (is.na(cv))
      if (sd(d_f)/mean(d_f) < error) {
        d_freq = d_f
        break
      }
    }
    
    mean(d_freq)
  }))
  return(cbind(mat, ff=freqs))
}

calc_ff2_batch = function(info, label="a", lbuffer=0, rbuffer=0, min_freq=1, error=.01, thresh=.1) {
  info = as.data.frame(info)
  d = foreach(row=isplitRows(info, chunkSize=1), .combine="rbind" ) %dopar% {
    wav = readWave(row[1, "wav"])
    #print(row[1,"wav"])
    wavf = filtersong(wav)
    mat = load_mat(row[1, "mat"])
    
    mat = mat %>% dplyr::filter(labels==label)
    if (nrow(mat) > 0) {
      ff = cbind(calc_ff2(wavf, mat, lbuffer=lbuffer, rbuffer=rbuffer, min_freq=min_freq, error=error, thresh=thresh), mat = row[1,"mat"])
      return(ff)
    } else {
      return(NULL)
    }
  }
  d
}
calc_freq_rolling_batch = function(info, label="a", offset=8) {
  d = foreach(row=isplitRows(info, chunkSize=1), .combine="rbind") %dopar% {
    print(row[1,"wav"])
    wav = readWave(row[1, "wav"])
    wavf = filtersong(wav)
    mat = load_mat(row[1, "mat"])
    
    
    mat = mat %>% filter(labels==label)
    #mat = mat[mat$offsets - mat$onsets]
    if (nrow(mat) > 0) {
      res = mat %>% rowwise() %>% do({calc_freq_rolling(wavf, offset=offset, subregion=unlist(.[1:2]))})
      return(cbind(mat, res, mat = row[1,"mat"]))
    } else {
      return(NULL)
    }
  }
  d
}
calc_freq_rolling = function(wav, offset=4, step = 4, duration = 8, subregion=NULL, fraction_max=.05) {
  wl = 512
  res = 512 / wav@samp.rate
  offset = offset / 1000
  null_df = data.frame(freq = NA)
  if (!is.null(subregion)) {
    from = subregion[1] + offset
    to = subregion[2] - offset
    if ((to - from) < res ) return(null_df)
    psd = spectro(wav, wl=512, norm=F, fftw = T, dB = NULL, plot=F, PSD=T, tlim=c(from, to), ovlp=50)
  } else {
    stop("Please specify subregion!")
  }
  
  max_overall = max(psd[[3]])
  
  peaks = apply(psd[[3]], 2, function(x) {
    f = findpeaks_freq(cbind(psd[[2]], x), 
                       min_value=2, 
                       max_gap=1, 
                       min_size=0, 
                       thresh=max_overall*fraction_max, 
                       absolute=T)
    if (nrow(f)==0) return(NA)
    
    power = apply(f, 1, function(peak) {
      inds = c(which(psd[[2]]==peak[1]), which(psd[[2]]==peak[2])) # select frequency corresponding to power peak
      mean(x[inds])
    })
    
    fmean = cbind(freq = rowMeans(f), power) 
    return(fmean[which.min(fmean[,1]),])
  })
  
  if (length(na.omit(peaks)) == 0) return(null_df)
  if (class(peaks) == "list") {
    peaks = na.omit(do.call(rbind, peaks))
  } else {
    peaks = t(peaks)
    #print("here")
  }
  total_power = sum(peaks[,"power"])
  return( data.frame(freq = as.numeric(t(peaks[,"freq"]) %*% peaks[,"power"] / total_power )))
}

calc_freq = function(wav, offset=10, duration=8, band=NULL, subregion=NULL) {
  psd = NULL
  if (!is.null(subregion)) {
    from = subregion[1] + offset
    to = from + duration
    psd = spec(wav, wl=512, norm=F, plot=F, PSD=T, from=(from / 1000), to=(to / 1000))
  } else {
    stop("Please specify subregion!")
  }
  
  psd[,1] = 1000 * psd[,1] # convert to Hertz from kHertz
  if (is.null(band)) band = c(1, nrow(psd))
  psd1 = psd[psd[,1]>band[1] & psd[,1]<band[2],]
  colnames(psd1) = c("freq", "power")
  psd1 = as.data.frame(psd1)
  psd1$onsets = subregion[1]
  psd1$offsets = subregion[2]
  #return(as.data.frame(psd1))
  return(psd1[which.max(psd1[,2]),1])
}
