library(stats)
library(seewave)
library(tuneR)
library(signal)
library(reshape2)
library(ggplot2)
library(doMC)
library(foreach)
library(itertools)
library(R.matlab)
library(stringr)
library(plyr)
library(dplyr)
library(gridExtra)
library(parallel)
library(matlab)
library(lubridate)
#library(smoother)
registerDoMC(cores=10)

source("/home/brad/src/songanalysis/threshold.r")
source("/home/brad/src/songanalysis/clustering.R")

plot_2dspec = function(wav, peaks=NULL) {
  theme_set(theme_classic())
  manipulate({
    gg = ggspectro(wav, wl=256, ovlp=75) + geom_tile(aes(fill=amplitude)) 
    gg = gg + scale_fill_gradientn(colours=spectro.colors(30), limits=c(-90, 0), na.value="transparent")
    gg = gg + xlim(xmin, xmax) + ylim(2, 15)
    gg
  }, 
  xmax=slider(0, length(wav) / wav@samp.rate, initial=length(wav)/wav@samp.rate),
  xmin=slider(0, length(wav) / wav@samp.rate, initial=0))
}



######## SYLLABLE CLASSIFICATION ########

#' Extract song features from wav file and peaks file generated by evsonganaly
#' @param wav, unfiltered Wave file
#' @param peaks, as generated by load_mat function
#' @return data.frame with song features that classify syllables well 
#'         (durations, wiener entropy, time-to-max amplitude, etc.)
extract_features = function(wav, peaks) {
  wavf = filtersong(wav)
  peaks = peaks[as.numeric(peaks$onsets)>.005,]
  peaks = peaks %>% filter(!labels %in% c(" ", "n"))
  if (nrow(peaks) == 0) return(NULL)
  #peaks$ind = 1:nrow(peaks)
  peaks$onsets.frames = peaks[,"onsets"] * wav@samp.rate
  peaks$offsets.frames = peaks[,"offsets"] * wav@samp.rate
  
  durations = peaks[,"offsets"] - peaks[,"onsets"]
  
  amp = env(wavf, envt="abs", plot=F)
  data = apply(peaks, 1, function(row) {
    amp_window = amp[row["onsets.frames"]:row["offsets.frames"]]
    amplitude = mean(amp_window)
    max_amp = max(amp_window)
    time_to_max = which.max(amp_window)
    time_from_max = length(amp_window) - which.max(amp_window)
    went = wiener_entropy(wavf, band=c(2000, 10000), subregion=c(as.numeric(row["onsets"]), as.numeric(row["offsets"])))
    psd1 = foreach(step=c(.005, .007, .009, .011), .combine="cbind") %do% {
      psd = spec(wavf,  fftw = T, PSD = T, plot=F, at=as.numeric(row["onsets"]) + step)
      psd
    }
    psd1 = psd1[,c(1, seq(2, ncol(psd1), 2))]
    psd = cbind(psd1[,1], apply(psd1[,2:ncol(psd1)], 1, mean))
    mid = round(nrow(psd)/2)
    psd_ratio = sum(psd[mid:nrow(psd),2]) / sum(psd[1:mid,2])
    max_freq = psd[which.max(psd[,2]),1]
    return(c(amplitude, time_to_max, time_from_max, went, max_freq, psd_ratio, psd[1:128,2]))
  })
  data = t(data)
  colnames(data) = c("amp", "time_to_max", "time_from_max", "went", "max_freq", "psd_ratio", paste("freq", 1:(ncol(data)-6), sep=""))
  data = data.frame(id=peaks$id, labels=peaks$labels, durations, data)
  data$labels = factor(data$labels)
  return(data)
}

extract_features2 = function(song, wl=512, feature_set="mid5_fixed", weighted=FALSE,
                             threshed=FALSE, threshed_val=10,
                             smoothed=TRUE, smoothed_window=4) {
  suppressMessages(require(smoother))
  feature_sets = c("mid3_fixed", "mid5_fixed", "mid3_rel", "mid5_fixed_5ms", "mid_mean")
  stopifnot(feature_set %in% feature_sets)
  
  wav = song$wav
  peaks = song$syllable
  if (is.null(peaks)) return(NULL)
  #peaks = peaks[as.numeric(peaks$ins)>.005,]
  
 ## Define frequency range (in kHz)
 res = wl / wav@samp.rate
 freq_limits = c(0, 12)
 freq_range = seq(0, wav@samp.rate / 2000, length.out=wl/2)
 ind_range = which(freq_range > freq_limits[1] & freq_range < freq_limits[2])
 
 ## Define frequency weights
 weights_init_x = c(1, length(ind_range))
 weights_init_y = c(1, 10)
 weights_target = 1:length(ind_range)
 weights = approx(weights_init_x, weights_init_y, weights_target)$y
 
  
  offset = .010
  peaks$mids = (peaks[,"outs"] + peaks[,"ins"]) / 2
  
  points = NULL
  buffer = wl / (2*wav@samp.rate)
  if (feature_set == "mid3_fixed") {
    points = matrix(0, nrow=nrow(peaks), ncol=3)   
    points[,1] = peaks[,"mids"] - offset
    points[,2] = peaks[,"mids"]
    points[,3] = peaks[,"mids"] + offset
  } else if (feature_set == "mid5_fixed") {
    points = matrix(0, nrow=nrow(peaks), ncol=5)  
    points[,1] = peaks[,"mids"] - offset * 2
    points[,2] = peaks[,"mids"] - offset
    points[,3] = peaks[,"mids"]
    points[,4] = peaks[,"mids"] + offset
    points[,5] = peaks[,"mids"] + offset * 2 
  } else if (feature_set == "mid5_fixed_5ms") {
    offset= .005
    points = matrix(0, nrow=nrow(peaks), ncol=5)  
    points[,1] = peaks[,"mids"] - offset * 2
    points[,2] = peaks[,"mids"] - offset
    points[,3] = peaks[,"mids"]
    points[,4] = peaks[,"mids"] + offset
    points[,5] = peaks[,"mids"] + offset * 2 
  } else if (feature_set == "mid3_rel") {
    points = matrix(0, nrow=nrow(peaks), ncol=3)  
    points[,1] = peaks[,"ins"] + buffer
    points[,2] = peaks[,"mids"]
    points[,3] = peaks[,"outs"] - buffer
  } else if (feature_set == "mid_mean") {
    points = matrix(0, nrow=nrow(peaks), ncol=2)
    points[,1] = peaks[,"ins"] - buffer
    points[,2] = peaks[,"outs"] + buffer
  }
  dur = seewave::duration(wav)
  
  # Filter out peaks on edge of recording
  ind = points[,1]<(2*buffer) | points[,ncol(points)] > (dur- (2*buffer))
  points = points[!ind,]
  peaks = peaks[!ind,]
  
 # points[points>(dur-buffer)] = (dur-buffer)
  #points = points[(points[,2] - points[,1]) > 2*buffer,]
  peaks$ins.frames = peaks[,"ins"] * wav@samp.rate
  peaks$outs.frames = peaks[,"outs"] * wav@samp.rate
 # peaks[,1:2] = peaks[,1:2] + offset

  psd1 = NULL
  data = NULL
    data = foreach(row=isplitRows(points, chunkSize=1), .inorder = T, .combine="rbind") %do% {
    #tomid = row[1,"mids"] - row[1,"ins"]
    
    #if (tomid < res) {
    #  psd1 = c(meanspec(wav, wl=512, fftw=T, PSD=T, norm = F, plot=F,  at=as.numeric(row["in"]))[ind_range,"y"],
    #           meanspec(wav, wl=512, fftw=T, PSD=T, norm = F, plot=F,  at=as.numeric(row["mids"]))[ind_range,"y"])
               #meanspec(wav, wl=512, fftw=T, PSD=T, norm = F, plot=F,  at=as.numeric(row["outs"]))[ind_range,"y"])
    #} else {
     # psd1 = c(meanspec(wav, wl=512, fftw=T, PSD=T, norm=F,  plot=F, from=as.numeric(row["ins"]), to=as.numeric(row["mids"]))[ind_range,"y"],
    #         meanspec(wav, wl=512, fftw=T, PSD=T, norm=F, plot=F, from=as.numeric(row["mids"]), to=as.numeric(row["outs"]))[ind_range,"y"])
      d = NULL
      psd1 = NULL
      if (feature_set %in% c("mid_mean")) {
        psd1 = seewave::meanspec(wav, wl=wl, fftw=T, PSD=F, norm=F, plot=F, from=row[1], to=row[2])[ind_range,"y"]
      } else {
        psd1 = foreach(x= isplitCols(row, chunkSize=1), .combine="c") %do% {
          d = seewave::spec(wav, wl=wl, fftw=T, PSD=F, norm=F,  plot=F, at=x)[ind_range,"y"]
          if (weighted) d = d * weights
          d
        }
      } 
  
    if (threshed) {
      psd1 = psd1 - song$thresh * threshed_val
      psd1[psd1 < 1] = 1
    }
    if (smoothed) {
      psd1 = na.omit(smth.gaussian(psd1, window = smoothed_window ))
    }
    return(psd1)
  }
  rownames(data) = peaks$id
  return(data)
}

extract_features_batch = function(info) {
  data = foreach(row=isplitRows(info, chunkSize=1), .combine="rbind") %dopar% {
    wav = readWave(row[1, "wav"])
    mat = load_mat(row[1, "mat"])
    ex = extract_features(wav, mat)
    ex
  }
  syl_table = table(data$labels)
  data = droplevels(data[!data$labels %in% names(syl_table)[syl_table<(nrow(data) * .05)],])
  data
}

extract_features_syl = function(wav, mat, subsamp=1, wl=1024) {
  fs = wav@samp.rate
  window = wl / fs
  if (is.null(mat[[3]]))
    return(list(syls=NULL,
                gaps=NULL))
  
  peaks = data.frame(ins=mat$onsets, outs=mat$offsets, labels=parse_labels(mat))
  peaks[,1:2] = peaks[,1:2] / 1000
  peaks = peaks %>% filter(!(labels %in% c(" ", "-")))
  peaks = peaks %>% filter(ins>window, outs<(seewave::duration(wav)-window))
  if (nrow(peaks) < 2)
    return(list(syls=NULL, 
                gaps=NULL))

  durations = peaks[,2] - peaks[,1]
  # Gap durations
  gap_durations = vector("numeric", length = nrow(peaks) - 1)
  for (i in 1:(length(gap_durations)-1)) {
    gap_durations[i] = peaks[i+1,1] - peaks[i,2]
  }
  
  # amplitude properties
  amp = abs(wav@left[seq(1, length(wav@left), subsamp)])
  syl_amps = peaks %>% rowwise() %>% do({
    amps = amp[(round(as.numeric(.[1])*fs / subsamp)):(round(as.numeric(.[2])*fs / subsamp))]
    time_to_max = which.max(amps) * subsamp / fs
    time_from_max = (length(amps) - which.max(amps)) * subsamp / fs
    half_max_1 = time_to_max / 2
    half_max_2 = time_from_max + (time_from_max / 2)
    half_max_duration = half_max_2 - half_max_1
    
    spec_feat = calc_spectral_features(wav, wl=wl, subregion=c(as.numeric(.[1]), as.numeric(.[2])), overlap=0)
    data.frame(mean_syl_amp=mean(amps),
      sd_syl_amp=sd(amps),
      time_to_max = time_to_max,
      spec_feat
    )
  })
  
  out = cbind(peaks,
              durations,
              syl_amps)
  return(list(syls=out, gaps=gap_durations))
}

#' Train random forest classifier on syllable labels and song features
#' @param data, song feature file as generated by extract_features
#' @return randomForest object
rf_syllables = function(data) {
  require(randomForest)
  #ind = sample(1:nrow(data), replace = F, size = round(nrow(data)*.80))
  #train = data[ind,]
  #test = data[-ind,]
  #fit.rf = randomForest(labels~., train, xtest = test[,2:ncol(test)], ytest = test[,1], ntree=5000)
  fit.rf = randomForest(labels~., data, ntree=5000)
  return(fit.rf)
}

#' Train random forest classifier on syllable labels and song features
#' @param data, song feature file as generated by extract_features
#' @return randomForest object
rf_syllables2 = function(data) {
  #ind = sample(1:nrow(data), replace = F, size = round(nrow(data)*.80))
  #train = data[ind,]
  #test = data[-ind,]
  #fit.rf = randomForest(labels~., train, xtest = test[,2:ncol(test)], ytest = test[,1], ntree=5000)
  fit.rf = randomForest(labels~., data, ntree=5000)
  return(fit.rf)
}


predict_syllables = function(rf, data) {
  pred = predict(rf, data)  
}

test_rf_sample_size = function(data) {
  ind = sample(1:nrow(data), round(nrow(data)*.8), replace=F)
  train = data[ind,]
  test = data[-ind,]
  test_ind = seq(100, nrow(train), 100)
  rs = mclapply(test_ind, function(x) {
    rf = lapply(1:10, function(x) {
                
      rf = randomForest(labels~., train[sample(1:nrow(train), test_ind, replace=F),], xtest = test[,2:ncol(test)], ytest = test[,1], ntree=5000)
      confusion = rf$confusion
      n = confusion
      off_ind = lower.tri(confusion) | upper.tri(confusion)
      off = sum(confusion[off_ind])
      on = sum(confusion[!off_ind])
      return(off / on)
    })
    mean(unlist(rf))
  }, mc.cores=10)
  rs = unlist(rs)
  return(data.frame(ind = test_ind, error= rs))
}

plot_clustering_3d = function(data) {
  require(plotly)
  plot_ly(data, x = PC1, 
          y = PC2, 
          z = PC3, 
          color = sc,
          #size = PC4,
          type = "scatter3d", 
          mode = "markers", 
          filename="r-docs/3d-scatter")
}

# plot_classified_syllable_multi = function(songs, syls, num_syls=5) {
#   
#   syls_sub = syls %>% group_by(called) %>%$ do({sample_n(., num_syls)})
#   song_names = str_replace(syls_sub$id, "-[0-9]", ".wav")
#   
#   
# }

plot_syllable_range = function(song, duration=2) {
  wav = song$wav
  peaks = song$syllable
  dots <- lapply(label_name, as.symbol)
  
  peaks_s = peaks %>% group_by_(.dots=dots) %>% do({
    if (nrow(.)<=num_syls) {
      return(.)
    } else {
      return(sample_n(., num_syls))  
    }
  })
  peaks_s1 = split(peaks_s, peaks_s[,label_name])
  #par(mfrow)
  
  
  
}
plot_classified_syllable = function(song, label_name="called", num_syls=5) {
  
  wav = song$wav
  peaks = song$syllable
  dots <- lapply(label_name, as.symbol)
  
  peaks_s = peaks %>% group_by_(.dots=dots) %>% do({
    if (nrow(.)<=num_syls) {
      return(.)
    } else if (nrow(.) == 0) {
      return(NA)
    } else {
      return(sample_n(., num_syls))  
    }
  })
  peaks_s = droplevels(peaks_s)
  peaks_s1 = split(peaks_s, peaks_s[,label_name])
  #par(mfrow)
  plots = lapply(1:length(peaks_s1), function(d)  {
    suppressWarnings(plot_multiple_syl(wav, peaks_s1[[d]][,1:2], title=names(peaks_s1)[d] ))
  })
  
  ncol = 3
  nrow = ceiling(length(plots) / ncol)
  plot.list = c(plots, list(ncol=ncol, nrow=nrow))
  do.call(grid.arrange, plot.list)
}

plot_spectro = function(wav, subregion=NULL, wl=512, overlap=50, labels=NULL, label_name = "called") {
  require(matlab)
  spectrogram = spectro(wav, plot = FALSE, tlim=subregion, fftw=T)
  frequency = rep(spectrogram$freq, times = ncol(spectrogram$amp))
  time = rep(spectrogram$time, each = nrow(spectrogram$amp))
  amplitude = as.vector(spectrogram$amp)
  df = data.frame(time, frequency, amplitude)
  gg = ggplot(df, aes_string(x = "time", 
                            y = "frequency",
                            z = "amplitude"))
  gg = gg + stat_contour(aes(fill=..level..), geom="polygon", binwidth=1)
  gg = gg + scale_fill_gradientn("Amplitude, (db)",
                                 colours=jet.colors(7), 
                                 breaks=c(-40, -15, 0),
                                 limits=c(-40, -15),
                                 na.value="transparent")
  gg = gg + labs(x="Time", y="Frequency") + ylim(0,10) + xlim(subregion)
  
  if (!is.null(labels)) {
    labels$time = (labels$outs + labels$ins) / 2
    labels = cbind(labels, data.frame(frequency=0, amplitude=0))
    gg = gg + geom_text(data=labels, aes_string(label=label_name))
  }
  #print(gg)
  return(gg)
}

plot_multiple_syl = function(wav, subregions, wl=512, overlap=50, title="") {
  input = inputw(wav)
  wave = input$w
  f = input$f
  subregions$ind = 1:nrow(subregions)
  
  steps =  lapply(1:nrow(subregions), function(i) {
    sf = subregions[i,] * f
    seq(sf[1,1], sf[1,2], wl - (overlap * wl/100))
  })
  steps_num = sum(unlist(lapply(steps, length)))
  steps_max = max(unlist(lapply(steps, length)))
  data = matrix(0, nrow=(wl/2), ncol=(steps_max + 5) * nrow(subregions))
  for(row in 1:nrow(subregions)) {
   
    step = steps[[row]]
    z = stft(wave = wave, f = f, wl = wl, zp = 0, step = step, 
             wn = "hanning", fftw = TRUE, scale = T, complex = FALSE)
    #z = 20 * log10(z)
    data[,(row -1) * (steps_max + 5) + (1 : ncol(z))] = z
  }  
  
  datam = melt(data)
  maxz = max(datam$value)
  theme_set(theme_classic())
  gg = ggplot(datam, aes(Var2, Var1, z=value)) + stat_contour(aes(fill=..level..), geom="polygon", binwidth=.1)
  #gg = gg + scale_fill_gradientn(colours=rainbow(100), limits=c(50, maxz), breaks = seq(maxz-10, maxz), na.value="white" )
  #gg = gg + scale_fill_gradientn(colours=rainbow(7), guide=T, values = seq(maxz-100, maxz), rescaler = function(x, ...) x, oob = identity, na.value="white" )
  gg = gg + scale_fill_gradientn(colours=jet.colors(7), breaks=c(.1, 1),
                                 limits=c(0, 1), na.value="transparent")
  gg = gg + labs(x="", y="", title=title) + theme(axis.line=element_blank(),axis.text.x=element_blank(),
                                axis.text.y=element_blank(),axis.ticks=element_blank(),
                                axis.title.x=element_blank(),
                                axis.title.y=element_blank(),legend.position="none",
                                panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
                                panel.grid.minor=element_blank(),plot.background=element_blank())
  gg = gg + ylim(0,128)
  return(gg)
}

######## PEAK ANALYSIS ########

#' Find amplitude peaks in wav file
#' @param wav, the input Wave object
#' @param min_duration, minimum duration required for peak calling
#' @param max_gap, maximum distance (in ms) between peaks before merging
#' @param thresh, threshold for peak definition, defined as fraction of max amplitude
#' @return data.frame containing peak starts (col1) and stops (col2) defined in seconds
findpeaks = function(wav, min_duration=50, max_gap=75, thresh=0.1) {
  samp_rate = wav@samp.rate
  min_duration = min_duration * samp_rate / 1000 
  max_gap = max_gap * samp_rate / 1000
  wav_env = env(wav, plot=F)
  max_val = max(wav_env)
  wav_env = wav_env / max_val
  above_thresh_ind = which(wav_env[,1]>thresh) 
  thresh_diff = which(diff(above_thresh_ind)>max_gap)
  df = data.frame(ins=c(above_thresh_ind[1], 
                           above_thresh_ind[thresh_diff+1]),
                     outs=c(above_thresh_ind[thresh_diff], 
                            above_thresh_ind[length(above_thresh_ind)]))
  return(df[(df[,2] - df[,1])>min_duration,] / samp_rate)
  if ((df[,2] - df[,1]) == 0) return(NULL)
  return (df / samp_rate)
}

#' Find amplitude peaks in wav file, using absolute amplitude threshold
#' @param wav, the input Wave object
#' @param min_duration, minimum duration required for peak calling
#' @param max_gap, maximum distance (in ms) between peaks before merging
#' @param thresh, threshold for peak definition, defined as fraction of max amplitude
#' @return data.frame containing peak starts (col1) and stops (col2) defined in seconds
findpeaks_abs = function(wav, min_duration=50, max_gap=75, max_duration=300, thresh=1E7) {
  samp_rate = wav@samp.rate
  min_duration = min_duration * samp_rate / 1000 
  max_duration = max_duration * samp_rate / 1000 
  max_gap = max_gap * samp_rate / 1000
  wav_env = seewave::env(wav, envt = "abs", plot=F)
  #max_val = max(wav_env)
  #wav_env = wav_env / max_val
  above_thresh_ind = which(wav_env[,1]>thresh) 
  if (length(above_thresh_ind) == 0) return(data.frame())
  thresh_diff = which(diff(above_thresh_ind)>max_gap)
  df = data.frame(ins=c(above_thresh_ind[1], 
                        above_thresh_ind[thresh_diff+1]),
                  outs=c(above_thresh_ind[thresh_diff], 
                         above_thresh_ind[length(above_thresh_ind)]))
  durations = df[,2] - df[,1]
  ind = durations>min_duration & durations<max_duration
  return(df[ind,] / samp_rate)
  #if ((df[,2] - df[,1]) == 0) return(data.frame())
  #return (df / samp_rate)
}

#' Find amplitude peaks in wav file, using absolute amplitude threshold
#' @param wav, the input Wave object
#' @param min_duration, minimum duration required for peak calling
#' @param max_gap, maximum distance (in ms) between peaks before merging
#' @param thresh, threshold for peak definition, defined as fraction of max amplitude
#' @return data.frame containing peak starts (col1) and stops (col2) defined in seconds
findpeaks_abs_env = function(wav_env, samp_rate, min_duration=50, max_gap=75, max_duration=300, thresh=1E7, subsamp=1) {
  wav_env = as.matrix(wav_env[seq(1, nrow(wav_env), subsamp),])
  
  min_duration = min_duration * samp_rate / (1000 * subsamp) 
  max_duration = max_duration * samp_rate / (1000 * subsamp) 
  max_gap = max_gap * samp_rate / (1000 * subsamp)
  above_thresh_ind = which(wav_env[,1]>thresh) 
  if (length(above_thresh_ind) == 0) return(data.frame())
  thresh_diff = which(diff(above_thresh_ind)>max_gap)
  df = data.frame(ins=c(above_thresh_ind[1], 
                        above_thresh_ind[thresh_diff+1]),
                  outs=c(above_thresh_ind[thresh_diff], 
                         above_thresh_ind[length(above_thresh_ind)]))
  durations = df[,2] - df[,1]
  ind = durations>min_duration & durations<max_duration
  return(subsamp * df[ind,] / samp_rate)
  #if ((df[,2] - df[,1]) == 0) return(data.frame())
  #return (df / samp_rate)
}

findpeaks_range = function(wav, min_duration=50, max_gap=75, max_duration=300, thresh_range=seq(-1,1,.1), absolute=F, subsamp=1) {
  if (absolute) {
    thresh = threshold_auto(wav, mean_sd, log=F, abs=T, factor=thresh_range)
    wav_env = seewave::env(wav, envt = "abs", plot=F)
  } else {
    thresh = threshold_auto(wav, mean_sd, log=F, abs=F, factor=thresh_range)
    wav_env = as.matrix(wav@left^2)
  }

  #peaks = foreach(th=1:length(thresh_range)) %do% {
  

  samp_rate = wav@samp.rate
  peaks = lapply(1:length(thresh_range), function(th){
    peak = findpeaks_abs_env(wav_env, samp_rate, min_duration=min_duration, max_gap=max_gap, max_duration=max_duration, thresh=thresh[th], subsamp=subsamp)
    peak
  })
  peak_info = data.frame(num_peak = unlist(lapply(peaks, nrow)), thresh_factor=thresh_range)
  peak_info$num_peak_diff = c(0, diff(peak_info$num_peak))
  #ind = which.min(peak_info$num_peak_diff)
  ind = which.max(peak_info$num_peak_diff) + 2
  ind = ifelse(ind > length(peaks), length(peaks), ind)
  #print(peak_info$thresh_factor[ind])
  selected = peaks[[ind]]
  return(list(peaks=peaks[[ind]], thresh_factor=thresh_range[ind], thresh=thresh[ind]))
}


#' Find frequency peaks in PSD
#' @param wav, the input Wave object
#' @param min_size, minimum band size of peak
#' @param max_gap, maximum distance (in kHz) between peaks before merging
#' @param thresh, threshold for peak definition, defined as fraction of max amplitude
#' @return data.frame containing peak starts (col1) and stops (col2) defined in seconds
findpeaks_freq = function(mat, min_value=2, min_size=50, max_gap=100, thresh=0.1, absolute=FALSE) {
  
  mat = mat[mat[,1]>min_value,]
  if (!absolute) {
    max_val = max(mat[,2])
    mat[,2] = mat[,2] / max_val
  }
  scale_val = (mat[2,1] - mat[1,1])
  above_thresh_ind = which(mat[,2]>thresh) 
  if (length(above_thresh_ind) == 0) return(data.frame())
  thresh_diff = which(diff(above_thresh_ind)>(max_gap/scale_val))
  df = data.frame(ins=c(mat[above_thresh_ind[1],1], 
                        mat[above_thresh_ind[thresh_diff+1],1]),
                  outs=c(mat[above_thresh_ind[thresh_diff],1], 
                         mat[above_thresh_ind[length(above_thresh_ind)],1]))
  return(df[(df[,2] - df[,1])>min_size,])
}

#' Find temporal distance between peaks
#' @param peaks, data frame as outputted by findpeaks, col1 is peak starts, col2 is peak stops
#' @return vector of interpeak distances
peak_dist = function(peaks) {
  if (nrow(peaks)<2) return(NA)
  dists = vector("numeric", nrow(peaks)-1)
  for (i in 1:(nrow(peaks)-1)) {
    dists[i] = peaks[i+1,1] - peaks[i,2]
  }
  return(dists)
}

interpeak_midpoint = function(peaks) {
  if (nrow(peaks)<2) return(NA)
  dists = vector("numeric", nrow(peaks)-1)
  for (i in 1:(nrow(peaks)-1)) {
    dists[i] = sum(peaks[i+1,1] + peaks[i,2]) / 2
  }
  return(dists)
}

match_peaks = function(d1, d2, multisong=NULL, tol=.01) {
  d1_song = unlist(lapply(str_split(d1$id, "-"), function(x) x[1]))
  d2_song = unlist(lapply(str_split(d2$id, "-"), function(x) x[1]))
  d1_s = split(d1, d1_song)
  d2_s = split(d2, d2_song)
  
  if (length(d1_s) < length(d2_s)) {
    d2_s = d2_s[names(d2_s) %in% names(d1_s)]
  } else {
    d1_s = d1_s[names(d1_s) %in% names(d2_s)]
  }
  
  for(i in 1:length(d2_s)) {
    d1_curr = d1_s[[i]]
    d2_curr = d2_s[[i]]
    d1_mids = (d1_curr[,2] + d1_curr[,1]) / 2
    d2_mids = (d2_curr[,2] + d2_curr[,1]) / 2  
    mid_diffs = dist(d1_mids, d2_mids)
    
    if (length(d1_mids) < length(d2_mids)) {
      margin = 1
    } else {
      margin = 2
    }
    mins = apply(mid_diffs, margin, which.min)
    
    if (margin == 2) {
      d2_curr$id = paste(names(d2_s)[i], mins, sep="-")
      d2_s[[i]] = d2_curr
    } else {
      d1_curr$id = paste(names(d1_s)[i], mins, sep="-")
      d1_s[[i]] = d1_curr
    }
  }
  d1 = do.call(rbind, d1_s)
  d2 = do.call(rbind, d2_s)
  
  return(list(d1=d1, d2=d2))
}


plot_peaks = function(peaks, yval=-1E7, ...) {
  apply(peaks, 1, function(peak) {
    id = NULL
    
    if (length(grep('-', peak[3]))>0) {
      id = str_split(peak[3], "-")[[1]][2]
    } else {
      id = peak[3]
    }
    segments(as.numeric(peak[1]), yval, as.numeric(peak[2]), yval, ...)
    text(as.numeric((as.numeric(peak[2]) + as.numeric(peak[1]))/2), y=yval + yval*.5, labels = id)
  })
}

######## WIENER ENTROPY ########

#' stripped down version of seewave::spec
calc_psd_region = function(wav_matrix, f, wl = 512, wn = "hanning", fftw = TRUE, norm = TRUE, 
                    PSD = TRUE, from = NULL, to = NULL, at = NULL) {
  
  # input <- inputw(wave = wave, f = f)
#   wave <- input$w
#   f <- input$f
  #wave = as.matrix(wav@left)
  wave = wav_matrix
  #f = wav@samp.rate
  #rm(input)
  
  if (!is.null(from) && !is.null(to)) {
    #       if (from > to) 
    #         stop("'from' cannot be superior to 'to'")
    #       if (from == 0) {
    #         a <- 1
    #       }
    #       else 
    a <- round(from * f)
    b <- round(to * f)
    #    }
    wl <- (b - a) + 1
   # wave = wave[a:b,]
    wave <- as.matrix(wave[a:b, ])
  }
  if (!is.null(at)) {
    c <- round(at * f)
    wl2 <- wl%/%2
    wave <- as.matrix(wave[(c - wl2):(c + wl2), ])
  }
  n <- nrow(wave)
  W <- ftwindow(n, wn = wn)
  wave <- wave * W
  p <- fftw::planFFT(n)
  y <- Mod(fftw::FFT(wave[, 1], plan = p))
  
  y <- y[1:(n%/%2)]
  if (norm) {
    y <- y/max(y)
  }
  y <- ifelse(y == 0, yes = 1e-06, no = y)
  x <- seq(0, (f/2) - (f/wl), length.out = n%/%2)/1000
  if (PSD) 
    y <- y^2
  spec <- cbind(x, y)
  return(spec)

}
#' Calculate Wiener entropy of given frequency band in Wave object
#' @param wav, Wave object
#' @param band, selected frequency band
#' @param subregion, vector giving start and end of wav subregion to analyze, in seconds
#' @references https://en.wikipedia.org/wiki/Spectral_flatness
#' @return scalar, calculated Weiner entropy
wiener_entropy = function(wav, band=NULL, subregion=NULL) {
  psd = NULL
  wl = 512
  if (!is.null(subregion)) {
   # psd = seewave::spec(wav, wl=wl, plot=F, PSD=T, from=subregion[1], to=subregion[2], fftw=T)
    psd = calc_psd_region(as.matrix(wav@left), f=wav@samp.rate, wl=wl, from=subregion[1], to=subregion[2])
  } else {
    psd = spec(wav, wl=wl, plot=F, PSD=T)
  }
  
  psd[,1] = 1000 * psd[,1] # convert to Hertz from kHertz
  if (is.null(band)) band = c(1, nrow(psd))
  psd1 = psd[psd[,1]>band[1] & psd[,1]<band[2],]
  res = calc_wiener_entropy(psd1[,2])
  return(res)
}

calc_wiener_entropy = function(psd) {
  exp(mean(log(psd))) / mean(psd)
  #prod(psd)^(1/length(psd)) / mean(psd)
}

#' Calculate Wiener entropy of given frequency band in Wave object
#' @param wav_matrix, wav signal as matrix
#' @param band, selected frequency band
#' @param subregion, vector giving start and end of wav subregion to analyze, in seconds
#' @references https://en.wikipedia.org/wiki/Spectral_flatness
#' @return scalar, calculated Weiner entropy
wiener_entropy_mat = function(wav_matrix, f, wl = 512, band=NULL, subregion=NULL) {
  psd = NULL
  if (!is.null(subregion)) {
    # psd = seewave::spec(wav, wl=wl, plot=F, PSD=T, from=subregion[1], to=subregion[2], fftw=T)
    psd = calc_psd_region(wav_matrix, f=f, wl=wl, from=subregion[1], to=subregion[2])
  } else {
    psd = spec(wav, wl=wl, plot=F, PSD=T)
  }
  
  psd[,1] = 1000 * psd[,1] # convert to Hertz from kHertz
  if (is.null(band)) band = c(1, nrow(psd))
  psd1 = psd[psd[,1]>band[1] & psd[,1]<band[2],]
  res = exp(mean(log(psd1[,2]))) / mean(psd1[,2])
  return(res)
}

#' Calculate spectral features iniven frequency band in Wave object
#' @param wav_matrix, wav signal as matrix
#' @param band, selected frequency band
#' @param subregion, vector giving start and end of wav subregion to analyze, in seconds
#' @references https://en.wikipedia.org/wiki/Spectral_flatness
#' @return scalar, calculated Weiner entropy
spectral_features_mat = function(wav_matrix, f, wl = 512, band=NULL, subregion=NULL) {
  psd = NULL
  if (!is.null(subregion)) {
    # psd = seewave::spec(wav, wl=wl, plot=F, PSD=T, from=subregion[1], to=subregion[2], fftw=T)
    psd = calc_psd_region(wav_matrix, f=f, wl=wl, from=subregion[1], to=subregion[2])
  } else {
    psd = spec(wav, wl=wl, plot=F, PSD=T)
  }
  
  psd[,1] = 1000 * psd[,1] # convert to Hertz from kHertz
  if (is.null(band)) band = c(1, nrow(psd))
  psd1 = psd[psd[,1]>band[1] & psd[,1]<band[2],]
  res = exp(mean(log(psd1[,2]))) / mean(psd1[,2])
  return(res)
}



wiener_entropy_var = function(wav, window=16, overlap=50, band=NULL, subregion=NULL) {
  subregion = subregion * 1000
  steps = seq(0, subregion[2]-subregion[1], window * overlap / 100)
  wav_duration = duration(wav)
  res = sapply(steps, function(step) {
    subregion2 = subregion 
    subregion2[1] = subregion[1] + step
    subregion2[2] = subregion2[1] + window
    subregion2 = subregion2 / 1000
    if (subregion2[2] > wav_duration) return(NA)
    wiener_entropy(wav, band=band, subregion=subregion2)
  })
  res = na.omit(res)
  var(res)
}

wiener_entropy_var2 = function(wav, wl=512, window=.016, overlap=50, band=NULL, subregion=NULL) {
  
  steps = seq(0, subregion[2]-subregion[1], window * overlap / 100)
  wav_duration = length(wav@left) / wav@samp.rate
 
  subregion2 = subregion
  wav_mat = as.matrix(wav@left)
  res = sapply(steps, function(step) {
    subregion2[1] = subregion[1] + step
    subregion2[2] = subregion2[1] + window
    if (subregion2[2] > wav_duration) return(NA)
    #wiener_entropy(wav, band=band, subregion=subregion2)
    wiener_entropy_mat(wav_mat, f=wav@samp.rate, band=band, subregion=subregion2, wl=wl)
  })
  res = na.omit(res)
  data.frame(went_mean = log2(mean(res)), went_var = var(res))
}

calc_spectral_features_nowav = function(fname, wl=512, band=NULL, subregion=NULL, overlap=50) {
  wav = filtersong(readWave(fname))
  calc_spectral_features(wav, wl=wl, band=band, subregion=subregion, overlap=overlap)
}

calc_spectral_features = function(wav, wl=512, band=NULL, subregion=NULL, overlap=50) {
  window = wl / wav@samp.rate
  fs = wav@samp.rate
  steps = seq(0, subregion[2]-subregion[1], window * (100-overlap) / 100)
  wav_duration = length(wav@left) / fs
  subregion2 = subregion
  wav_mat = as.matrix(wav@left)
  freqs = seq(0, (fs-1) / 2, fs / (wl))
  res = lapply(steps, function(step) {
    subregion2[1] = subregion[1] + step
    subregion2[2] = subregion2[1] + window
    if (region_on_edge(wav_duration, fs, wl, subregion2[1], subregion2[2])) return(rep(NA, times=wl/2))
    #if (subregion2[1] < 0 || subregion2[2] > wav_duration) return(rep(NA, times=wl/2))
    #wiener_entropy(wav, band=band, subregion=subregion2)
    calc_psd_region(wav_mat, f = fs, wl = wl, fftw = T, PSD=T, at = subregion2[1])[,2]
    #spectral_mat(wav_mat, f=wav@samp.rate, band=band, subregion=subregion2, wl=wl)
  })
  res = do.call("cbind", res)
  res = t(na.omit(t(res)))
  went = apply(res, 2, function(x) calc_wiener_entropy(x)) 
  went_mean = mean(went)
  went_var = var(went)
  
  res = sweep(res, 2, colSums(res), "/")
  freq_mean_col = freqs %*% res
  freq_mean = mean(freq_mean_col[1,])
  freq_cv = sd(freq_mean_col[1,]) / freq_mean
  #res = do.call("rbind", res)
  #res = na.omit(res)
  cnames = c("freq_mean", "freq_cv", "went_mean", "went_var")
  data = data.frame(mget(cnames), check.names = F)
  return(data)
}

wiener_entropy_var2.1 = function(wav,  window=.016, overlap=50, band=NULL, subregion=NULL) {
  
  steps = seq(0, subregion[2]-subregion[1], window * overlap / 100)
  #print(steps)
  wav_duration = duration(wav)
  #subregion2 = subregion
  subregion2 = matrix(0, nrow=length(steps), ncol=2)
  subregion2[,1] = subregion[1] + steps
  subregion2[,2] = subregion2[,1] + window
  #print(subregion2)
  #subregion2 = subregion2 / 1000
  subregion2 = subregion2[subregion2[,2]<wav_duration,]
  res = apply(subregion2, 1, function(row) {
    
    wiener_entropy(wav, band=band, subregion=row)
    #subregion2[1] = subregion[1] + step
    #subregion2[2] = subregion2[1] + window
    #if (subregion2[2] > wav_duration) return(NA)
    
  })
  res = na.omit(res)
  data.frame(went_mean = log2(mean(res)), went_var = var(res))
}

#' Calculate Weiner entropy of given frequency band in PSD
#' @param psd, PSD as output from spec(PSD=T)
#' @param band, selected frequency band
#' @references https://en.wikipedia.org/wiki/Spectral_flatness
#' @return scalar, calculated Weiner entropy
weiner_entropy_psd = function(psd, region=c(6,8)) {
  psd1 = psd[psd[,1]>region[1] & psd[,1]<region[2],]
  res = exp(mean(log(psd1[,2]))) / mean(psd1[,2])
  return(res)
}

#' Calculate Weiner entropy and Wiener entropy variance given info file
#' as returned by load_mat_file
#' @param info, info file as returned by load_mat_file
#' @param band, selected frequency band
#' @return data.frame, given info file supplmented with calculated values
#'   \item{went}{wiener entropy}
#'   \item{wev}{variance of wiener entropy across syllable}
wiener_stats = function(info, band=c(2000, 10000)) {
  d = foreach(row=isplitRows(info, chunkSize=1)) %dopar% {
   # print(row["mat"])
    out = load_mat(row["mat"])
    wav = readWave(row[1, "wav"])
    #out = transform(out, onsets=onsets * 1000, offsets = offsets * 1000)
    out = out %>% rowwise() %>% do({
      cbind(., wiener_entropy_var2(wav, band=band, subregion=c(.$onsets, .$offsets)))
    })
    out$mat = row[1, "mat"]
    out
  }
  do.call(rbind, d)
}

######### SONG FINDERS ########
#' Classify Wave object as song or not song
#'     First filters for small Weiner entropy values within given band
#'     Next filters for small interpeak distances
#' @param wav, Wave object
#' @param band, selected frequency band
#' @param wein_thresh, maximum allowed Wiener entropy in frequency band
#' @param dist_thresh, maximum interpeak distance allowed
#' @return logical, song or not song
songfinder = function(wav, band=c(5000,7000), 
                      wein_thresh=0.4, 
                      dist_thresh = 0.06,
                      min_duration = 1000) {
  wav = filtersong(wav)
  wein = wiener_entropy(wav, band=band)
  if (wein > wein_thresh) {
    return(FALSE)
  } 
  peaks = findpeaks(wav, min_duration=min_duration, max_gap=200, thresh=0.05) 
  return(nrow(peaks) > 0)
}

compute_amp_ratio = function(amp, samp.rate, peaks, max_gap=50, subsamp=1, min_num_gaps=5) {

  if (nrow(peaks) <= 2) 
    return(1)
  max_gap = max_gap / 1000
 
  gaps = matrix(0, nrow=nrow(peaks) - 1, ncol=2)
  gaps[,1] = peaks[1:(nrow(peaks) - 1), 2]
  gaps[,2] = peaks[2:(nrow(peaks)), 1]
  
  ind = (gaps[,2] - gaps[,1])<max_gap
  gaps = matrix(gaps[ind,], ncol=2)
  
  if (nrow(gaps)<min_num_gaps) {
    return(1)
  } else {
    peak_ind = sapply(which(ind), function(x) c(x, x+1))
    peaks = peaks[unique(c(peak_ind)),]
    peak_amp = mean(apply(peaks, 1, function(x) {
      d = amp[round((x[1]*samp.rate)/subsamp):(round(x[2]*samp.rate)/subsamp)]
      mean(d)
    }))
    gap_amp = mean(apply(gaps, 1, function(x) {
    d = amp[(round(x[1]*samp.rate)/subsamp):(round(x[2]*samp.rate)/subsamp)]
    mean(d)
    }))
  }
  amp_ratio = gap_amp / peak_amp
}
songfinder2 = function(wav, 
                       max_gap = 10, 
                       min_duration = 15,
                       max_duration = 300 , 
                       thresh=0.2, 
                       min_num_peaks = 5, 
                       max_num_peaks=10,
                       amp_ratio_max_gap=100) {
  #wavf = filtersong(wav)
  wavf = highpass_filter(wav, from = 500, wl = 1024, ovlp = 25)
  #amp = env(wavf, envt = "abs")
  subsamp = 10
  #peaks = findpeaks_abs(wavf, min_duration=min_duration, max_gap=max_gap, max_duration=max_duration, thresh=thresh)
  peak_info = findpeaks_range(wavf, min_duration = min_duration, 
                              max_duration = max_duration, 
                              max_gap = max_gap, 
                              absolute = F, 
                              thresh_range=seq(-.4, .4, .1),
                              subsamp=subsamp)
  peaks = peak_info$peaks
  num_peaks = nrow(peaks)
  thresh = peak_info$thresh
  #return(peaks)
  if (num_peaks < min_num_peaks) return(FALSE)
  
  # Filter for poor amplitude definition of peaks
  amp = abs(wavf@left[seq(1,length(wavf@left), subsamp)])
  
  amp_ratio = compute_amp_ratio(amp, wavf@samp.rate, peaks, max_gap=amp_ratio_max_gap, subsamp=subsamp)
  rate = num_peaks / (peaks[num_peaks,2] - peaks[1,1])
  total_duration = peaks[num_peaks,2] - peaks[1,1]
  peak_dists = peak_dist(peaks)
  peak_dists = peak_dists[peak_dists<0.5]
  cv_peak_dist = sd(peak_dists) / mean(peak_dists)
  res = (total_duration > 0.5) & 
        (amp_ratio < .2) & (amp_ratio > 0) &
        (cv_peak_dist < 1.5) & (cv_peak_dist > 0)
        
      #  (num_peaks >= min_num_peaks)
   # (rate > min_num_peaks ) & 
  #  (rate < max_num_peaks ) & 
#      nrow(peaks) > 12 &
    
  return(res)
}

songfinder3 = function(wav, 
                       to_return=NULL, 
                       max_gap = 10, 
                       min_duration = 15, 
                       max_duration = 300, 
                       min_num_peaks = 5, 
                       max_num_peaks=NULL,
                       thresh_method=mean_sd,
                       thresh_factor=1.5) {
  wavf = filtersong(wav)
  wavf = rmnoise(wavf, output="Wave")
  fs = wav@samp.rate
  
  # Identify peak regions
  thresh = threshold_auto(wavf, thresh_method, log=T, factor=thresh_factor)
  peaks = findpeaks_abs(wavf, min_duration=min_duration, max_gap=max_gap, max_duration=max_duration, thresh=thresh)
  
  #return(peaks)
  if (nrow(peaks) < 8) return(FALSE)
  
  # Durations
  durations = peaks[,2] - peaks[,1]
  
  # Filter by gap durations. Subsong has regular gaps
  gap_durations = vector("numeric", length = nrow(peaks) - 1)
  for (i in 1:(length(gap_durations)-1)) {
    gap_durations[i] = peaks[i+1,1] - peaks[i,2]
  }
  if (to_return=="gap_durations")
    return(gap_durations)

  return((total_duration > 1) & (rate > min_num_peaks ) & (rate < max_num_peaks ))
}

songfinder_features = function(wav, filtersong=TRUE, rmnoise=FALSE, max_gap = 10, min_duration = 15, max_duration = 300 , thresh_method=mean_sd, thresh_factor=.25, min_num_peaks = 5, max_num_peaks=10) {
  wavf = NULL
  if (filtersong) { 
    #wavf = filtersong(wav)
    wavf = highpass_filter(wav, from = 500, wl = 1024, ovlp = 25)
  } else {
    wavf = wav
  }
  if (rmnoise)
    wavf = rmnoise(wavf, output="Wave")
  fs = wav@samp.rate
  #thresh = threshold_auto(wavf, mean_sd, sd_factor=sd_factor)

  # Identify peak regions
  #thresh = threshold_auto(wavf, thresh_method, log=T, factor=thresh_factor)
  #peaks = findpeaks_abs(wavf, min_duration=min_duration, max_gap=max_gap, max_duration=max_duration, thresh=thresh)
  peak_info = findpeaks_range(wavf, min_duration = min_duration, max_gap = max_gap, max_duration = max_duration)
  peaks = peak_info$peaks
  num_peaks = nrow(peaks)
  thresh_factor = peak_info$thresh_factor
  thresh = peak_info$thresh
  # syllable rate, or number of syllables in peak region
  if (nrow(peaks) > 0) {
    rate = nrow(peaks) / (peaks[nrow(peaks),2] - peaks[1,1])
  } else {
    rate = 0
  }
  
  # total duration of peak region.
  if (nrow(peaks) > 0) {
    total_duration = peaks[nrow(peaks),2] - peaks[1,1]
  } else {
    total_duration = 0
  }
  
  # Durations
  if (nrow(peaks) > 1) {
    durations = peaks[,2] - peaks[,1]
    mean_durations = mean(durations)
    med_durations = median(durations)
    q75_durations = quantile(durations, .75)
    sd_durations = sd(durations)
  } else if (nrow(peaks) == 1) {
    durations = unlist(peaks[2] - peaks[1])
    mean_durations = durations
    med_durations = durations
    q75_durations = durations
    sd_durations = 0
  } else {
    mean_durations = 0
    med_durations = 0
    q75_durations = 0
    sd_durations = 0
  }
  
  # Gap durations
  if (nrow(peaks) > 2) {
    gap_durations = vector("numeric", length = nrow(peaks) - 1)
    for (i in 1:(length(gap_durations)-1)) {
      gap_durations[i] = peaks[i+1,1] - peaks[i,2]
    }
    mean_gap_durations = mean(gap_durations)
    med_gap_durations = median(gap_durations)
    sd_gap_durations = sd(gap_durations)
  } else if (nrow(peaks) == 2) {
    mean_gap_durations = peaks[2,1] - peaks[1,2]
    med_gap_durations = peaks[2,1] - peaks[1,2]
    sd_gap_durations = 0
  } else {
    mean_gap_durations = 0
    med_gap_durations = 0
    sd_gap_durations = 0
  }
  
  # amplitude properties
  amp = seewave::env(wavf, envt="abs", plot=F)
  mean_amp = mean(amp)
  sd_amp = sd(amp)
  
  if (nrow(peaks) > 1) { 
    syl_amps = apply(peaks[,1:2], 1, function(peak) {
      amps = amp[(peak[1]*fs):(peak[2]*fs)]
      time_to_max = which.max(amps)
      time_from_max = length(amps) - which.max(amps)
      half_max_1 = time_to_max / 2
      half_max_2 = time_from_max + (time_from_max / 2)
      half_max_duration = half_max_2 - half_max_1
      c(mean_syl_amp=mean(amps), 
        sd_syl_amp=sd(amps),
        time_to_max = time_to_max,
        time_from_max = time_from_max,
        half_max_duration = half_max_duration)
    })
    mean_syl_amps = mean(syl_amps[1,])
    sd_syl_amps = mean(syl_amps[2,])
    mean_time_to_max = mean(syl_amps[3,])
    med_time_to_max = median(syl_amps[3,])
    min_time_to_max = min(syl_amps[3,])
    max_time_to_max =max(syl_amps[3,])
    q25_time_to_max = quantile(syl_amps[3,], .25)
    q75_time_to_max = quantile(syl_amps[3,], .75)
    sd_time_to_max = sd(syl_amps[3,])
    mean_time_from_max = mean(syl_amps[4,])
    med_time_from_max = median(syl_amps[4,])
    sd_time_from_max = sd(syl_amps[4,])
    #mean_syl_amps = mean(syl_amps[1,])
    #sd_syl_amps = mean(syl_amps[2,])
    mean_half_max_duration = mean(syl_amps[5,])
    med_half_max_duration = median(syl_amps[5,])
    min_half_max_duration = min(syl_amps[5,])
    max_half_max_duration =max(syl_amps[5,])
    q25_half_max_duration = quantile(syl_amps[5,], .25)
    q75_half_max_duration = quantile(syl_amps[5,], .75)
  } else {
    mean_syl_amps = 0
    sd_syl_amps = 0
    mean_time_to_max = 0
    med_time_to_max = 0
    sd_time_to_max = 0
    mean_time_from_max = 0
    med_time_from_max = 0
    sd_time_from_max = 0
    min_time_to_max =0
    max_time_to_max =0
    q25_time_to_max = 0
    q75_time_to_max =0
    mean_half_max_duration = 0
    med_half_max_duration = 0
    min_half_max_duration = 0
    max_half_max_duration = 0
    q25_half_max_duration = 0
    q75_half_max_duration = 0
  }
  
  # spectral
  if (nrow(peaks) > 1) { 
    syl_ents = apply(peaks[,1:2], 1, function(peak) {
      wiener_entropy_var2(wavf, subregion = c(peak[1], peak[2]), overlap = 75)
    })
    syl_ents = do.call(rbind, syl_ents)
    mean_syl_went = mean(syl_ents[,1])
    sd_syl_went = sd(syl_ents[,1])
    mean_syl_wev = mean(syl_ents[,2])
    sd_syl_wev = sd(syl_ents[,2])
  } else {
    mean_syl_went = 0
    sd_syl_went = 0
    mean_syl_wev = 0
    sd_syl_wev = 0
  }
  
  thresh_log=log(thresh+1)
  mean_amp_log=log(mean_amp+1)
  sd_amp_log=log(sd_amp+1)
  mean_syl_amps_log=log(mean_syl_amps+1)
  sd_syl_amps_log=log(sd_syl_amps+1)
  cv_gap_durations = unlist(sd_gap_durations / mean_gap_durations)
  cv_durations = unlist(sd_durations / mean_durations)
  cv_syl_amps = unlist(sd_syl_amps_log / mean_syl_amps_log)
  cv_gap_durations[is.nan(cv_gap_durations)] = 0
  cv_durations[is.nan(cv_durations)] = 0
  cv_syl_amps[is.nan(cv_syl_amps)] = 0
  
  cnames = c("thresh",
             "thresh_factor",
             "num_peaks",
             "rate",
             "total_duration",
             "mean_durations",
             "med_durations",
             "q75_durations",
             "sd_durations",
             "mean_gap_durations",
             "med_gap_durations",
             "sd_gap_durations",
             "mean_amp",
             "sd_amp",
             "mean_syl_amps",
             "sd_syl_amps",
             "mean_time_to_max",
             "med_time_to_max",
             "sd_time_to_max",
             "min_time_to_max",
             "max_time_to_max",
             "q25_time_to_max",
             "q75_time_to_max",
             "mean_time_from_max",
             "med_time_from_max",
             "sd_time_from_max",
             "mean_half_max_duration",
             "med_half_max_duration",
             "min_half_max_duration",
             "max_half_max_duration",
             "q25_half_max_duration",
             "q75_half_max_duration",
             "mean_syl_went",
             "sd_syl_went",
             "mean_syl_wev",
             "sd_syl_wev", 
             "thresh_log",
             "mean_amp_log",
             "sd_amp_log",
             "mean_syl_amps_log",
             "sd_syl_amps_log",
             "cv_gap_durations",
             "cv_durations",
             "cv_syl_amps")
           
  data = data.frame(mget(cnames), check.names = F)
#   data = c(thresh=thresh, 
#            thresh_factor=thresh_factor,
#            num_peaks=nrow(peaks),
#            rate=rate,
#            total_duration=total_duration,
#            mean_durations=mean_durations,
#            med_durations=med_durations,
#            q75_durations=q75_durations,
#            sd_durations=sd_durations,
#            mean_gap_durations=mean_gap_durations,
#            med_gap_durations=med_gap_durations,
#            sd_gap_durations=sd_gap_durations,
#            mean_amp=mean_amp,
#            sd_amp=sd_amp,
#            mean_syl_amps=mean_syl_amps,
#            sd_syl_amps=sd_syl_amps,
#            mean_time_to_max=mean_time_to_max,
#            med_time_to_max=med_time_to_max,
#            sd_time_to_max=sd_time_to_max,
#            min_time_to_max=min_time_to_max,
#            max_time_to_max=max_time_to_max,
#            q25_time_to_max=q25_time_to_max,
#            q75_time_to_max=q75_time_to_max,
#            mean_time_from_max=mean_time_from_max,
#            med_time_from_max=med_time_from_max,
#            sd_time_from_max=sd_time_from_max,
#            mean_half_max_duration =  mean_half_max_duration,
#            med_half_max_duration = med_half_max_duration,
#            min_half_max_duration =min_half_max_duration,
#            max_half_max_duration =max_half_max_duration,
#            q25_half_max_duration = q25_half_max_duration,
#            q75_half_max_duration =  q75_half_max_duration,
#            mean_syl_went=mean_syl_went,
#            sd_syl_went=sd_syl_went,
#            mean_syl_wev=mean_syl_wev,
#            sd_syl_wev=sd_syl_wev)
  return(data)
}

songfinder_features_clean = function(wav, rmnoise=TRUE, max_gap = 10, min_duration = 15, max_duration = 300 , thresh_method=mean_sd, thresh_factor=.25, min_num_peaks = 5, max_num_peaks=10) {
  #wavf = filtersong(wav)
  wavf = highpass_filter(wav, from = 500, wl = 1024, ovlp = 25)
  if (rmnoise)
    wavf = rmnoise(wavf, output="Wave")
  fs = wav@samp.rate

  # Identify peak regions
  peak_info = findpeaks_range(wavf, 
                              min_duration = min_duration, 
                              max_gap = max_gap, 
                              max_duration = max_duration, 
                              thresh_range = seq(0,2,.2), 
                              absolute = T)
  peaks = peak_info$peaks
  thresh_factor = peak_info$thresh_factor
  thresh = peak_info$thresh
  thresh_log = log(thresh + 1)
  num_peaks = nrow(peaks)
  
#   output_cnames = c("mean_time_to_max",    
#                      "q75_time_to_max.75.", 
#                      "med_time_to_max",     
#                      "med_durations",       
#                      "cv_syl_amps",         
#                      "mean_durations",      
#                      "cv_gap_durations",   
#                      "mean_syl_went",       
#                      "thresh",              
#                      "q25_time_to_max.25.", 
#                      "sd_durations",        
#                      "rate",                
#                      "mean_gap_durations",  
#                      "total_duration",     
#                      "mean_syl_wev",        
#                      "sd_time_to_max",      
#                      "cv_durations",        
#                      "sd_gap_durations")
  
#   output_cnames = c("q75_time_to_max.75.",
#                     "med_durations",
#                     "mean_time_to_max",
#                     "med_time_to_max",
#                     "sd_gap_durations",
#                     "mean_durations",     
#                     "cv_syl_amps",
#                     "cv_gap_durations",
#                     "med_gap_durations",
#                     "q25_time_to_max.25.",
#                     "mean_syl_wev",
#                     "mean_gap_durations", 
#                     "min_time_to_max",
#                     "med_time_from_max",
#                     "sd_time_to_max",
#                     "sd_amp",
#                     "thresh",
#                     "mean_syl_went")
 
  output_cnames = c("med_time_to_max", 
                    "q75_time_to_max", 
                    "q25_time_to_max",
                    "cv_gap_durations", 
                    "cv_durations",
                    "med_durations",
                    "med_gap_durations",
                    "mean_syl_wev", 
                    "mean_syl_went",
                    "num_peaks",
                    "cv_syl_amps",
                    "rate",
                    "thresh_log",
                    "mean_amp_log")  
  
  if (is.null(min_num_peaks)) min_num_peaks = 0
  if (is.null(max_num_peaks)) max_num_peaks = 1E5
  if ((nrow(peaks) < min_num_peaks) || (nrow(peaks) > max_num_peaks)) 
    return(data.frame(matrix(NA, ncol=length(output_cnames), dimnames=list("", output_cnames))))
  
  # number of peaks / second
  num_peaks = nrow(peaks)
  rate = num_peaks / (peaks[num_peaks,2] - peaks[1,1])

  # total duration of peak region.
  total_duration = peaks[nrow(peaks),2] - peaks[1,1]
  
  # Durations
  durations = peaks[,2] - peaks[,1]
  med_durations = median(durations)
  mean_durations = mean(durations)
  sd_durations = sd(durations)
  cv_durations = sd_durations / mean_durations
  
  # Gap durations
  gap_durations = vector("numeric", length = nrow(peaks) - 1)
  for (i in 1:(length(gap_durations)-1)) {
    gap_durations[i] = peaks[i+1,1] - peaks[i,2]
  }
  mean_gap_durations = mean(gap_durations)
  med_gap_durations = median(gap_durations)
  sd_gap_durations = sd(gap_durations)
  cv_gap_durations = sd_gap_durations / mean_gap_durations
  
  # amplitude properties
  amp = seewave::env(wavf, envt="abs", plot=F)
  mean_amp = mean(amp)
  mean_amp_log = log(mean_amp + 1)
  sd_amp = sd(amp)
  #max_amp = max(amp)
  #mean_max_amp = mean(amp) / max_amp
  syl_amps = apply(peaks[,1:2], 1, function(peak) {
    amps = amp[(peak[1]*fs):(peak[2]*fs)]
    time_to_max = which.max(amps)
    time_from_max = length(amps) - which.max(amps)
    c(mean_syl_amp=mean(amps), 
      sd_syl_amp=sd(amps),
      time_to_max = time_to_max,
    time_from_max = time_from_max)
  })
  mean_syl_amps = mean(syl_amps[1,])
  sd_syl_amps = mean(syl_amps[2,])
  cv_syl_amps = log(sd_syl_amps+1) / log(mean_syl_amps+1)
  mean_time_to_max = mean(syl_amps[3,])
  med_time_to_max = median(syl_amps[3,])
  q75_time_to_max = quantile(syl_amps[3,], .75)
  q25_time_to_max = quantile(syl_amps[3,], .25)
  min_time_to_max = min(syl_amps[3,])
  sd_time_to_max = sd(syl_amps[3,])
  #mean_time_from_max = mean(syl_amps[4,])
  #med_time_from_max = median(syl_amps[4,])
  #sd_time_from_max = sd(syl_amps[4,])
  
  # Spectral
  syl_ents = apply(peaks[,1:2], 1, function(peak) {
    wiener_entropy_var2(wavf, subregion = c(peak[1], peak[2]), overlap = 75)
  })
  syl_ents = do.call(rbind, syl_ents)
  mean_syl_went = mean(syl_ents[,1])
  #sd_syl_went = sd(syl_ents[,1])
  mean_syl_wev = mean(syl_ents[,2])
  #sd_syl_wev = sd(syl_ents[,2])
  
  data = as.data.frame(mget(output_cnames))
  colnames(data) = output_cnames
  return(data)
}


songfinder_psd = function(psd, 
                          band=c(5,8), 
                          wein_thresh=0.45) {
  wein = weiner_entropy_psd(psd, region=band)
  return(wein<wein_thresh)
}

######## Cepstrum ########
format_cepstrum = function(data) {
  wav_cep_form = melt(data$amp)
  colnames(wav_cep_form) = c("time", "quef", "amp")
  wav_cep_form$time = data$time
  wav_cep_form$quef = rep(data$quef, each=length(data$time))
  return(wav_cep_form)
}

#' Calcualte dynamic cepstrum of wav file 
#' @param Wave object
#' @return cepstrum as dataframe: 1:time, 2:quef, 3:amp
compute_cepstrum_time = function(wav) {
  wav_cep = cepstro(wav, wl=256, ovlp=50)
  return(format_cepstrum(wav_cep))
}

#' Calculate derivative of dynamic cepstrum using least-square approximation
#' @param Wave object
#' @param w, window size
#' @return delta cepstrum as data.frame: 1:time, 2:quef, 3: local derivative
delta_cepstrum = function(wav, w=10, region=NULL) {
  wav_cep = NULL
  if (is.null(region)) {
    wav_cep = cepstro(wav, wl=512, ovlp=50, collevels = seq(0, .01, .001), ylim=c(0, 1) )
  } else {
    wav_cep = cepstro(wav, wl=512, ovlp=50, from=region[1], to=region[2])
  }
  wav_cepf = format_cepstrum(wav_cep)
  wav_cep_mat = wav_cep$amp
  delta_cep = matrix(nrow=(nrow(wav_cep_mat) - (2*w)), ncol=ncol(wav_cep_mat))
  inds = seq(-1*w, w)
  
  #### loop through rows of wav_cep
  norm_factor = inds %*% inds
  for (i in 1:nrow(delta_cep)) {
      delta_cep[i,] = t(inds) %*% wav_cep_mat[(i+w + inds),]
  }
  delta_cep = delta_cep / norm_factor[1,1]
  
  delta_cep_form = melt(delta_cep)
  colnames(delta_cep_form) = c("time", "quef", "amp")
  delta_cep_form$time = wav_cep$time[(w+1):(nrow(wav_cep_mat) - w)]
  delta_cep_form$quef = rep(wav_cep$quef, each=nrow(delta_cep))
  return(delta_cep_form)
}

ggplot_cepstrum = function(data) {
  limits = c(min(data$amp), quantile(data$amp, probs=.99))
  gg = ggplot(data, aes(time, quef, fill=amp)) +  geom_tile() + scale_fill_gradient(limits=limits)
  gg = gg + ylim(0, .7)
  return(gg) 
}

######## Fundamental frequency ########
calc_ff = function(wav, peaks) {
  
  psd = apply(peaks, 1, function(x) spec(wav, wl = 512, PSD=T, from=x[1], to=x[2], plot=F))
  psd_peaks = lapply(psd, function(data) {
    total_power = sum(data[,2])
    d = findpeaks_freq(data, min_size=0)
    d %>% rowwise() %>% summarize(ins=ins, 
                                  outs=outs, 
                                  prop=sum(data[data[,1]>ins & data[,1]<outs,2])/total_power)
  })
  return(psd_peaks)
}

calc_ff = function(wav, mat) {
  
  #psd = apply(mat, 1, function(x) spec(wav, PSD=T, from=as.numeric(x["onsets"]), to=as.numeric(x["offsets"]), plot=F))
  #if (class(psd) == "matrix") psd = list(cbind(1:nrow(psd), psd))
  freqs = unlist(lapply(psd, function(data) {
    d = findpeaks_freq(data, min_value=2, max_gap=1000, min_size=0, thresh=.1)
    maxes = apply(d, 1, function(x) max(psd[x[1]:x[2]]))
    d = d[which.max(maxes),]
    #d_mean = apply(d, 1, mean)
    #d_mean = data.frame(ind=1:length(d_mean), d_mean=d_mean)
    #d_freq = apply(d_mean, 1, function(x) x[2]/x[1])
    #mean(d_freq)
  }))
  
  #if (nrow(mat) == 1) {
  #  return(c(mat, freqs))
  #} else {
  return(cbind(mat, freqs))
  #}
}

#' Calculate fundamental frequency by averaging harmonics
#' @param wav, input Wave file
#' @param mat, data.frame containing onsets, offsets, and label as generated by load_mat
#' @return mat file supplemented with calculated fundamental frequency
calc_ff2 = function(wav, mat) {
  
  psd = apply(mat, 1, function(x) spec(wav, PSD=T, from=as.numeric(x["onsets"]), to=as.numeric(x["offsets"]), plot=F))
  if (class(psd) == "matrix") psd = list(cbind(1:nrow(psd), psd))
  freqs = unlist(lapply(psd, function(data) {
    
    d = findpeaks_freq(data, min_value=2, max_gap=1000, min_size=0, thresh=.1)
    d_mean = apply(d, 1, mean)
    d_mean = data.frame(ind=1:length(d_mean), d_mean=d_mean)
    d_freq = apply(d_mean, 1, function(x) x[2]/x[1])
    mean(d_freq)
  }))
  
  return(cbind(mat, freqs))

}

calc_ff2_batch = function(info, label="a") {
  d = foreach(row=isplitRows(info, chunkSize=1), .combine="rbind" ) %dopar% {
    wav = readWave(row[1, "wav"])
    wavf = filtersong(wav)
    mat = load_mat(row[1, "mat"])
    
    mat = mat %>% filter(labels==label)
    if (nrow(mat) > 0) {
      return(cbind(calc_ff2(wavf, mat), mat = row[1,"mat"]))
    } else {
      return(NULL)
    }
  }
  d
}
calc_freq_rolling_batch = function(info, label="a", offset=8) {
  d = foreach(row=isplitRows(info, chunkSize=1), .combine="rbind" ) %dopar% {
    print(row[1,"wav"])
    wav = readWave(row[1, "wav"])
    wavf = filtersong(wav)
    mat = load_mat(row[1, "mat"])
    
    
    mat = mat %>% filter(labels==label)
    #mat = mat[mat$offsets - mat$onsets]
    if (nrow(mat) > 0) {
      res = mat %>% rowwise() %>% do({calc_freq_rolling(wavf, offset=offset, subregion=unlist(.[1:2]))})
      return(cbind(mat, res, mat = row[1,"mat"]))
    } else {
      return(NULL)
    }
  }
  d
}
calc_freq_rolling = function(wav, offset=4, step = 4, duration = 8, subregion=NULL, fraction_max=.05) {
  wl = 512
  res = 512 / wav@samp.rate
  offset = offset / 1000
  null_df = data.frame(freq = NA)
  if (!is.null(subregion)) {
    from = subregion[1] + offset
    to = subregion[2] - offset
    if ((to - from) < res ) return(null_df)
    psd = spectro(wav, wl=512, norm=F, fftw = T, dB = NULL, plot=F, PSD=T, tlim=c(from, to), ovlp=50)
  } else {
    stop("Please specify subregion!")
  }
  
  max_overall = max(psd[[3]])
  
  peaks = apply(psd[[3]], 2, function(x) {
    f = findpeaks_freq(cbind(psd[[2]], x), 
                       min_value=2, 
                       max_gap=1, 
                       min_size=0, 
                       thresh=max_overall*fraction_max, 
                       absolute=T)
    if (nrow(f)==0) return(NA)
  
    power = apply(f, 1, function(peak) {
      inds = c(which(psd[[2]]==peak[1]), which(psd[[2]]==peak[2])) # select frequency corresponding to power peak
      mean(x[inds])
    })
    
    fmean = cbind(freq = rowMeans(f), power) 
    return(fmean[which.min(fmean[,1]),])
    })
  
  if (length(na.omit(peaks)) == 0) return(null_df)
  if (class(peaks) == "list") {
    peaks = na.omit(do.call(rbind, peaks))
  } else {
    peaks = t(peaks)
    #print("here")
  }
  total_power = sum(peaks[,"power"])
  return( data.frame(freq = as.numeric(t(peaks[,"freq"]) %*% peaks[,"power"] / total_power )))
}

calc_freq = function(wav, offset=10, duration=8, band=NULL, subregion=NULL) {
  psd = NULL
  if (!is.null(subregion)) {
    from = subregion[1] + offset
    to = from + duration
    psd = spec(wav, wl=512, norm=F, plot=F, PSD=T, from=(from / 1000), to=(to / 1000))
  } else {
    stop("Please specify subregion!")
  }
 
  psd[,1] = 1000 * psd[,1] # convert to Hertz from kHertz
  if (is.null(band)) band = c(1, nrow(psd))
  psd1 = psd[psd[,1]>band[1] & psd[,1]<band[2],]
  colnames(psd1) = c("freq", "power")
  psd1 = as.data.frame(psd1)
  psd1$onsets = subregion[1]
  psd1$offsets = subregion[2]
  #return(as.data.frame(psd1))
  return(psd1[which.max(psd1[,2]),1])
}

calc_mean_freq = function(wav, subregion, overlap) {
  ms = meanspec(wav, wl = 256, ovlp = overlap, fftw = T, from = subregion[1], to = subregion[2], plot=F)
  ms
}

compute_class = function(res, trues) {
  tp = vector("numeric", 4)
  for(i in 1:nrow(trues)) {
    m = match(trues[i,1], res[,1])
    if (trues[i,2] & res[m,2]) { #TP
      tp[1] = tp[1] + 1
    } else if (trues[i,2] & !res[m,2]) { #FN
      tp[2] = tp[2] + 1
    } else if (!trues[i,2] & res[m,2]) { #FP
      tp[3] = tp[3] + 1
    } else if (!trues[i,2] & !res[m,2]) { #TN
      tp[4] = tp[4] +1
    }
  }
  names(tp) = c("TP", "FN", "FP", "TN")
  return(tp)
}

######## SEQUENCING ########
parse_labels = function(mat, select=NULL) {
  d.labels = as.character(mat$labels)
  label_list = unlist(str_split(d.labels, ""))
  return(label_list)
  #d.labels = unlist(lapply(mat, function(x) as.character(x$labels)))
  #label_list = lapply(d.labels, function(x) unlist(str_split(x, "")))
}

syllable_transition = function(mat, select=NULL) {
  label_list = lapply(mat, parse_labels)
  
  return(syl_trans(label_list, select=select))
}
syllable_transition_df = function(df_list) {
  label_list = lapply(df_list, function(x) as.character(x$labels))
  return(syl_trans(label_list))
}

syl_trans = function(label_list, select) {
  label_list_cat = unlist(label_list)
  
  totals = table(label_list_cat)
  labels = NULL
  if (is.null(select)) {
    labels = names(totals)
  } else {
    labels = select
  }
  
  labels2 = c("start", labels, "end")
  counts = matrix(0, nrow=length(labels2), ncol=length(labels2), dimnames=list(labels2, labels2))
  
  for (i in 1:length(label_list)) {
    #print(paste("i", i, sep=""))
    curr = label_list[[i]]
    curr = curr[curr %in% labels]
    if (length(curr) <= 1) next
      counts["start", curr[1]] = counts["start", curr[1]] + 1
    for (j in 1:(length(curr)-1)) {
        counts[curr[j],curr[j+1]] = counts[curr[j],curr[j+1]] + 1
    }
    counts[curr[length(curr)], "end"] = counts[curr[length(curr)], "end"] + 1
  }
  return(counts)  
}


process_syllable_matrix = function(info, select=NULL, norm="total") {
   # print(info$mat)
    d = lapply(info$mat, function(x) {
      m = readMat(x)
      if (is.null(m[[3]])) 
          return(NULL)
      return(m)})
    if (is.null(d[[1]]))
      return(data.frame(From="-", To="-", value=0))
    syl = syllable_transition(d, select)
    if (!is.null(select)) {
      syl = syl[rownames(syl) %in% select, colnames(syl) %in% select]
    }
    
    if (norm=="total") {
      syl = syl / sum(c(syl))
    } else if (norm=="row") {
      syl = sweep(syl, MARGIN = 1, STATS = rowSums(syl), "/")
    } else if (norm=="none") {
      syl = syl
    }
    m = melt(syl)
    colnames(m)[1:2] = c("From", "To")
    m = m %>% filter(From!="end") %>% filter(To!="start") 
    #print(m)
    return(m)
}



#' Calculate repeat lengths by bout
#' @param data, info file as returned from load_mat_info
#' @return data.frame
#'   \item{lengths}{length as from rle}
#'   \item{values}{repeated syllable}
#'   \item{mat}{original .not.mat file}
repeat_lengths = function(data) {
  require(foreach)
  require(itertools)
  d = foreach(row=isplitRows(data, chunkSize=1)) %dopar% {
    mat = readMat(row["mat"])
    labels = as.character(mat$labels)
    labels1 = unlist(str_split(labels, ""))
    rles = rle(labels1)
    rd = data.frame(lengths=rles$lengths, values=rles$values, mat=row["mat"])
    rd = rd[rd$values %in% select,]
    rd
  }
  do.call(rbind, d)
}

mean_transition_entropy_long = function(long_data) {
  mean_transition_entropy(acast(long_data, From~To, fun.aggregate = sum))
}

mean_transition_entropy = function(mat) {
  mat = mat / sum(c(mat))
  res = apply(mat, 1, calc_entropy)
  data.frame(transition_entropy = sum(unlist(res)))
}

calc_entropy = function(x) {
  y = x[x>0]
  -1 * sum(y * log2(y))
}

