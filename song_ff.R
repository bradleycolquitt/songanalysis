source("~/data2/rstudio/birds/utils/stats.R")

######## Fundamental frequency ########
calc_ff = function(wav, peaks) {
  
  psd = apply(peaks, 1, function(x) spec(wav, wl = 512, PSD=T, from=x[1], to=x[2], plot=F))
  psd_peaks = lapply(psd, function(data) {
    total_power = sum(data[,2])
    d = findpeaks_freq(data, min_size=0)
    d %>% rowwise() %>% summarize(ins=ins, 
                                  outs=outs, 
                                  prop=sum(data[data[,1]>ins & data[,1]<outs,2])/total_power)
  })
  return(psd_peaks)
}



calc_ff = function(wav, mat) {
  #psd = apply(mat, 1, function(x) spec(wav, PSD=T, from=as.numeric(x["onsets"]), to=as.numeric(x["offsets"]), plot=F))
  #if (class(psd) == "matrix") psd = list(cbind(1:nrow(psd), psd))
  freqs = unlist(lapply(psd, function(data) {
    d = findpeaks_freq(data, min_value=2, max_gap=1000, min_size=0, thresh=.1)
    maxes = apply(d, 1, function(x) max(psd[x[1]:x[2]]))
    d = d[which.max(maxes),]
    #d_mean = apply(d, 1, mean)
    #d_mean = data.frame(ind=1:length(d_mean), d_mean=d_mean)
    #d_freq = apply(d_mean, 1, function(x) x[2]/x[1])
    #mean(d_freq)
  }))
  
  #if (nrow(mat) == 1) {
  #  return(c(mat, freqs))
  #} else {
  return(cbind(mat, freqs))
  #}
}

#' Calculate fundamental frequency by averaging harmonics
#' @param wav, input Wave file
#' @param mat, data.frame containing onsets, offsets, and label as generated by load_mat
#' @param buffer, number of seconds to contract segmented syllable. applied to both onset and offset
#' @param min_freq, parameter supplied to findpeaks_freq, peaks below this value are removed
#' @param error, cv of inferred FF must be below this value
#' @return mat file supplemented with calculated fundamental frequency
calc_ff2 = function(wav, mat, lbuffer=0, rbuffer=0, min_freq=1, nharm=NULL, error = .01, thresh=.1, wl=1024, to_plot=F) {
  fs = wav@samp.rate
  window = wl / fs
  
  psd = NULL
  #psd = apply(mat, 1, function(x) spec(wav, PSD=T, from=as.numeric(x[1])+buffer, to=as.numeric(x[2])-buffer, plot=F))
  if (nrow(mat)==1) {
    from = as.numeric(mat[1,1])+lbuffer
    to = as.numeric(mat[1,2])-rbuffer
    if ((to-from)<window) {
      psd = NA
    } else {
      psd = spec(wav, wl=wl, PSD=T, from=from, to=to, plot=to_plot)
    }
  } else {
    #mat$plot = FALSE
    #if (to_plot) {
    ##  mat$plot[2] = TRUE
    #}
    psd = apply(mat, 1, function(x) {
      from = as.numeric(x[1])+lbuffer
      to = as.numeric(x[2])-rbuffer
      if ((to-from)<window) {
        return(NA)
      } else {
        spec(wav, wl=wl, PSD=T, from=from, to=to, plot=F)
      }
    })
  }

  if (is.na(psd))
    return(cbind(mat, ff=NA))
  
  if (class(psd) == "matrix") psd = list(psd)
  freqs = unlist(lapply(psd, function(data) {
    if(is.na(data))
      return(NA)
    data[data[,1]<min_freq,2] = 0
    data[,2] = data[,2] / max(data[,2])
  
    d = findpeaks_freq(data, min_value=min_freq, max_gap=.4, min_size=0, thresh=thresh)
    if (nrow(d)==1) {
      return(rowMeans(d))
    }
    d_mean = apply(d, 1, mean)
    
    if (is.null(nharm)) {
      test_steps = seq(1:nrow(d))      
    } else {
      test_steps = 1:nharm
    }
    
    test_steps1 = lapply(0:3, function(i) test_steps + i)
    
    d_freq = NA
    for (i in 1:length(test_steps1)) {
      d_f = d_mean[1:length(test_steps)] / test_steps1[[i]]
      cv = sd(d_f)/mean(d_f)
      #if (is.na(cv))
      if (cv < error) {
        d_freq = d_f
        break
      }
    }
    
    mean(d_freq)
  }))
  return(cbind(mat, ff=freqs))
}

calc_ff2_batch = function(info, label="a", lbuffer=0, rbuffer=0, min_freq=1, nharm=NULL, error=.01, thresh=.1, to_plot=F) {
  info = as.data.frame(info)
  par(mfrow=c(3,3))
  info$plot = FALSE
  info$plot[sample(1:nrow(info), 9, replace=F)] = TRUE
  d = foreach(row=isplitRows(info, chunkSize=1), .combine="rbind" ) %do% {
    wav = readWave(row[1, "wav"])
    #print(row[1,"wav"])
    wavf = filtersong(wav)
    mat = load_mat(row[1, "mat"])
    
    mat = mat %>% dplyr::filter(labels==label)
    if (nrow(mat) > 0) {
      ff = cbind(calc_ff2(wavf, mat, lbuffer=lbuffer, rbuffer=rbuffer, min_freq=min_freq, nharm=nharm, error=error, thresh=thresh), mat = row[1,"mat"], to_plot=row[1,"plot"])
      return(ff)
    } else {
      return(NULL)
    }
  }
  d
}

test_psd = function(info, row_ind=1, syl_inds=1:4, label=label, lbuffer=0, rbuffer=0, min_freq=1, nharm=NULL, error=.05, thresh=.05) {  
  row = info[row_ind,]
 # print(row[,c("mat", "labels")])
  wav = readWave(row[1, "wav"])
  #print(row[1,"wav"])
  wavf = filtersong(wav)
  mat = load_mat(row[1, "mat"])
  
  mat = mat %>% dplyr::filter(labels==label)
  
  
  wl = 512
  par(mfrow=c(2,2))
  for (syl_ind in syl_inds) {
    from = as.numeric(mat[syl_ind,1])+lbuffer
    to = as.numeric(mat[syl_ind,2])-rbuffer
    data = spec(wav, wl=wl, PSD=T, from=from, to=to, plot=F)
    if(is.na(data))
      return(NA)
    data[data[,1]<min_freq,2] = 0
    data[,2] = data[,2] / max(data[,2])
    plot(data, type="l", main=paste(mat[syl_ind,"onsets"], sep=""))
  }

  calc_ff2(wavf,
           mat,
           lbuffer=lbuffer,
           rbuffer=rbuffer,
           min_freq=min_freq,
           nharm=nharm,
           error=error,
           thresh=thresh,
           to_plot=T)
}

calc_freq_rolling_batch = function(info, label="a", offset=8) {
  d = foreach(row=isplitRows(info, chunkSize=1), .combine="rbind") %dopar% {
    print(row[1,"wav"])
    wav = readWave(row[1, "wav"])
    wavf = filtersong(wav)
    mat = load_mat(row[1, "mat"])
    
    
    mat = mat %>% filter(labels==label)
    #mat = mat[mat$offsets - mat$onsets]
    if (nrow(mat) > 0) {
      res = mat %>% rowwise() %>% do({calc_freq_rolling(wavf, offset=offset, subregion=unlist(.[1:2]))})
      return(cbind(mat, res, mat = row[1,"mat"]))
    } else {
      return(NULL)
    }
  }
  d
}

#' Calculate fundamental frequency by averaging harmonics
#' @param wav, input Wave file
#' @param mat, data.frame containing onsets, offsets, and label as generated by load_mat
#' @param buffer, number of seconds to contract segmented syllable. applied to both onset and offset
#' @param min_freq, parameter supplied to findpeaks_freq, peaks below this value are removed
#' @param error, cv of inferred FF must be below this value
#' @return mat file supplemented with calculated fundamental frequency
calc_ff_auto = function(wav, mat, lbuffer=0, rbuffer=0, min_freq=1, max_freq=4, wl=1024, ovlp=0) {
  fs = wav@samp.rate
  window = wl / (fs )
 # max_freq = fs / 2
  ffs = NULL
  if (nrow(mat)==1) {
    from = as.numeric(mat[1,1])+lbuffer
    to = as.numeric(mat[1,2])-rbuffer
    if ((to-from)<window) {
      ffs = NA
    } else {
      ffs = median(calc_ff_auto_sub2(wav=wav, from=from, to=to, min_freq=min_freq, max_freq=max_freq, wl=wl, ovlp=ovlp))
    }
  } else {
    ffs = apply(mat, 1, function(x) {
      from = as.numeric(x[1])+lbuffer
      to = as.numeric(x[2])-rbuffer
      if ((to-from)<window) {
        return(NA)
      } else {
        median(calc_ff_auto_sub2(wav=wav, from=from, to=to, min_freq=min_freq, max_freq=max_freq, wl=wl, ovlp=ovlp))
      }
    })
  }
  
  if (is.na(ffs))
      return(cbind(mat, NA))
      
  return(cbind(mat, ff=ffs))
}

calc_ff_auto_sub = function(wav, from, to, min_freq, max_freq, wl, ovlp, threshold) {

  #wave = wav
  fs = wav@samp.rate
  wave = afilter(wave = wav, f = fs, threshold = threshold, plot = F)
  wave = matrix(wave[(from*fs):(to*fs),])

  #wave = matrix(wav@left[(from*fs):(to*fs)]) 
  #res = wl / (fs/2)
  res = fs / wl
  lag.min = round(res / (max_freq))
  lag.max = round(res / (min_freq))
  
  if (lag.max == wl) {
    lag.max = lag.max - 1
  }
  n = nrow(wave)
  step = seq(1, n - wl, (wl - (ovlp/100)*wl)) 
  N = length(step)
  #N = 1
  R = matrix(data = numeric((lag.max + 1) * N), lag.max + 1, N)
  R[is.nan(R)] = 0
  for (i in step) {
  #i = 1
    a = acf(wave[i:(wl + i - 1)], 
              lag.max = lag.max, 
               plot = FALSE)
    R[, which(step == i)] = as.vector(acf(wave[i:(wl + i - 1)], 
                                          lag.max = lag.max, 
                                          plot = FALSE)$acf)
  }
  R[is.nan(R)] = 0
  tfond = numeric(N)
  excl = 1:lag.min
  #excl = lag.min:N
  return(R)
  for (i in 1:N) {
    tfond[i] = fpeaks(R[-excl, i], f = NA, nmax = 1)[1]
  }
  tfond = tfond + length(excl)
  y = fs/tfond/1000
  x = seq(0, n/fs, length.out = N)
  d = cbind(x,y)
  return(d)
}

#' @param min_freq, kHz
#' @param max_freq, kHz
calc_ff_auto_sub2 = function(wav, from, to, min_freq, max_freq, wl, ovlp=75) {
  fs = wav@samp.rate
  ny = fs / 2
  step = ny / wl         # Width between bins (in s)
  freqbins = (wl/2)
  
  min_freq = min_freq * 1000
  max_freq = max_freq * 1000
  lag_min = round(max_freq / step)
  lag_max = round(min_freq / step)
  
  from_ind = from * fs
  to_ind = to * fs
  n_timebins = to_ind - from_ind
  wave = matrix(wav@left[from_ind:to_ind])

  timebins = seq(from_ind, from_ind + n_timebins, wl - (ovlp/100)*wl)
  psds = lapply(timebins, function(bin) {
    wave = matrix(wav@left[bin:(bin+wl)])
    calc_psd_region(wave, f = fs, wl = wl, fftw = T)[,2]
  })
  psd = do.call("cbind", psds)
  
  #harms = c(1,2)
  harms = 1
  minimums = freqbins - lag_min * harms
  maximums = freqbins - lag_max * harms
  
  est_freqbin = vector("numeric", ncol(psd))
  est_freqbin_harm = vector("numeric", length(harms))
  powers = vector("numeric", length(harms))
  #h = 1
  for (i in 1:ncol(psd)) {
    slice = psd[nrow(psd):1,i]
    for (h in harms) {
     # h  = 1
      freq_window = slice[minimums[h]:maximums[h]]
      max_pow = max(freq_window)
      max_ind = which.max(freq_window)
      
      if (max_ind == 1 || max_ind == length(freq_window)) {
        est_ind = max_ind
      } else {
        inds = c((max_ind-1) : (max_ind+1))
        est_ind = max_ind
        #estimated_ind = interp(inds, freq_window[inds])
      }
      est_ind = est_ind + minimums[h] - 1
      est_freqbin_harm[h] = (freqbins - est_ind) / harms[h]
      powers[h] = max_pow
    }
    powers_norm = powers / sum(powers)
    est_freqbin[i] = powers_norm %*% est_freqbin_harm
  }
  est_freq = est_freqbin * (ny/freqbins-1)
  return(est_freq)
}

calc_freq_rolling = function(wav, offset=4, step = 4, duration = 8, subregion=NULL, fraction_max=.05) {
  wl = 512
  res = 512 / wav@samp.rate
  offset = offset / 1000
  null_df = data.frame(freq = NA)
  if (!is.null(subregion)) {
    from = subregion[1] + offset
    to = subregion[2] - offset
    if ((to - from) < res ) return(null_df)
    psd = spectro(wav, wl=512, norm=F, fftw = T, dB = NULL, plot=F, PSD=T, tlim=c(from, to), ovlp=50)
    
  } else {
    stop("Please specify subregion!")
  }
  
  max_overall = max(psd[[3]])
  
  peaks = apply(psd[[3]], 2, function(x) {
    f = findpeaks_freq(cbind(psd[[2]], x), 
                       min_value=2, 
                       max_gap=1, 
                       min_size=0, 
                       thresh=max_overall*fraction_max, 
                       absolute=T)
    if (nrow(f)==0) return(NA)
    
    power = apply(f, 1, function(peak) {
      inds = c(which(psd[[2]]==peak[1]), which(psd[[2]]==peak[2])) # select frequency corresponding to power peak
      mean(x[inds])
    })
    
    fmean = cbind(freq = rowMeans(f), power) 
    return(fmean[which.min(fmean[,1]),])
  })
  
  if (length(na.omit(peaks)) == 0) return(null_df)
  if (class(peaks) == "list") {
    peaks = na.omit(do.call(rbind, peaks))
  } else {
    peaks = t(peaks)
    #print("here")
  }
  total_power = sum(peaks[,"power"])
  return( data.frame(freq = as.numeric(t(peaks[,"freq"]) %*% peaks[,"power"] / total_power )))
}

calc_freq = function(wav, offset=10, duration=8, band=NULL, subregion=NULL) {
  psd = NULL
  if (!is.null(subregion)) {
    from = subregion[1] + offset
    to = from + duration
    psd = spec(wav, wl=512, norm=F, plot=F, PSD=T, from=(from / 1000), to=(to / 1000))
  } else {
    stop("Please specify subregion!")
  }
  
  psd[,1] = 1000 * psd[,1] # convert to Hertz from kHertz
  if (is.null(band)) band = c(1, nrow(psd))
  psd1 = psd[psd[,1]>band[1] & psd[,1]<band[2],]
  colnames(psd1) = c("freq", "power")
  psd1 = as.data.frame(psd1)
  psd1$onsets = subregion[1]
  psd1$offsets = subregion[2]
  #return(as.data.frame(psd1))
  return(psd1[which.max(psd1[,2]),1])
}

calc_rolling_func = function(x, window=9, func="calc_cv") {
  out = vector("numeric", length = length(x))
  min_ind = ceil(window/2)
  max_ind = length(out) - (min_ind - 1)
  span = min_ind - 1
  for (i in min_ind:max_ind) {
    tmp = x[(i - span):(i+span)]
    out[i] = do.call(func, list(tmp))
  }
  return(out)
}